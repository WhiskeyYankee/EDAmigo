---
title: "EDAmigo Vignette"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{EDAmigo Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

EDAmigo is a package designed to make Exploratory Data Analysis (EDA) simple. It provides users with streamlined options for automatically cleaning, processing, and viewing their data. It also provides supports interactive EDA methods which experienced users may find useful. The following demonstration shows how EDAmigo can be used to support the EDA process:


# Step 1: Load package & Import Data

The first step in the EDA process is to import a dataset and load the EDAmigo library. The package comes with two example datasets: Fires and Finance  and will use the fires data for this example.

```{r setup}
library(EDAmigo)

# Define the dataframe
df <- fires
```


# Step 2: Manually Set Date Fields
Dates can be stored in a wide variety of ways and automatically processing all possible date storage types is outside of the scope of the EDAmigo package. EDAmigo requires all dates and times to be properly classed as 'Date', 'POSIXlt', or 'POSIXct.' If your dataset contains dates, you will need to set manually set them to 'Date', 'POSIXlt', or 'POSIXct' prior to proceeding. Let's check the classes of the columns of the fires dataframe using the str() function:

```{r}
str(df)

```

All of our date columns are type 'Date.' However, there are several special characters, improperly typed columns, and missing values. These can be handled using a variety of methods in EDAmigo.

# Step 3: Clean Data
The fires data set is an example of raw data that 

We can either use the autoClean() function to handle special characters, improperly typed columns, and missing values at the same time or handle each separately using handleSpecial(), detectTypes(), and handleMissing() individually. Let's use the autoClean() function.

```{r}
# Store output for future use.
# Pass in:  
  # the dataframe, 
  # special_user_level set to 0 indicating automatic special character removal with no user interaction
  # a factor tolerance of 1% to automatically coerce values with 1% or less unique values to factors
  # a user tolerance of 20%, this will prompt the user for direction when a column has <= 30% unique values
  # drop_user_level of 1, indicating that the user prefers to interact with the handleMissing() function


result <- autoClean(df, special_user_level = 0, factor_tol = 10, type_user_tol = 10
                    , drop_user_level = 0, impute_user_level = 0, impute_factors = TRUE)
```

autoClean() provides users with the ability to interact with the EDA process. In the example provided, interaction is turned off to allow the vignette to knit properly. However, videos will be included throughout this vignette to provide you with demonstrations of this interactivity.

<video width="900" height="675" autoplay loop muted>
  <source src="C:\Users\moore\Videos\Captures\EDAmigo - main - RStudio 2023-12-02 20-40-04.mp4" type="video/mp4">
</video>



In our example we are storing the autoClean() output as 'result.' Let's examine the output of autoClean() function. The function returned a list of 6 elements: clean_df, 


## clean_df
This is the resulting dataframe with special characters removed, columns coerced to an appropriate class, and missing values handled. Compared to our original dataframe, we see that 5 columns were removed and that many columns have been coerced to a different class. 
```{r}
# Store our clean dataframe for future use
cleaned_fires <- result$clean_df
str(cleaned_fires)

```

Now, let's look at the remaining output, which are derived from other functions.

## handleSpecial() output
This shows the special characters that were found, versus the special characters that were actually removed.
```{r}
# Examine results of the handleSpecial() function
result$special_found_replaced
```

## detectTypes() output
This output is a record of what the detectTypes() function changed. The first column indicates the % of unique values contained within the named column of the original dataframe. Next, we see the original column class, and the resulting column class.
```{r}
# Examine the results of the detectTypes() function
result$type_stats
```

## handleMissing() output
Lastly, the handleMissing output includes information about which columns are dropped, and at what point in the process. 'missing_stats' includes the percent of missing values for each column throughout each step in the process. It is important to note that this output may change, depending upon the options the user inputs and/or selects during interactive sections of the function.

The final list of dropped columns and dropped rows are also provided, so the user knows which rows and columns are no longer contained in the final dataframe.
```{r}
# Examine the results of the handleMissing() function
result$missing_stats
result$dropped_cols
result$dropped_rows
```


## boxCox
The boxCox function differs from the boxCox function in other packages in that it performs transformations on multiple columns at the same time and offers more output to help aid the EDA process. 

```{r}

fires_boxCox_Trans = boxCox(cleaned_fires)

```
